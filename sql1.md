Here's an advanced SQL interview exercise that covers multiple concepts, including complex joins, subqueries, window functions, aggregation, and optimization techniques. The problem is designed to test your ability to handle a wide range of SQL scenarios.

### Problem: Sales Analysis and Reporting

**Background:**

You are given the following tables:

1. **`Customers`**
   - `customer_id` (INT)
   - `customer_name` (VARCHAR)
   - `join_date` (DATE)
   - `country` (VARCHAR)

2. **`Products`**
   - `product_id` (INT)
   - `product_name` (VARCHAR)
   - `category` (VARCHAR)
   - `price` (DECIMAL)

3. **`Orders`**
   - `order_id` (INT)
   - `customer_id` (INT)
   - `order_date` (DATE)
   - `total_amount` (DECIMAL)

4. **`Order_Items`**
   - `order_item_id` (INT)
   - `order_id` (INT)
   - `product_id` (INT)
   - `quantity` (INT)
   - `price_at_purchase` (DECIMAL)

---

### Requirements:

1. **Customer's Lifetime Value (LTV)**:
   Write a query to calculate the total lifetime value (LTV) of each customer. LTV is the total amount spent by the customer across all their orders.

2. **Top 5 Customers by LTV**:
   Write a query to return the top 5 customers by lifetime value, including their `customer_name`, `LTV`, and the `country` they are from. Sort the results in descending order of LTV.

3. **Monthly Revenue Trend**:
   Write a query to show the total revenue for each month, ordered by the month and year. Include the `month_year` (formatted as `YYYY-MM`), and total revenue for that month.

4. **Products with the Highest Revenue**:
   Write a query to identify the top 5 products by revenue. For each product, return the `product_name`, `category`, and the total revenue generated by the product. The revenue should be the sum of `(price_at_purchase * quantity)` for all orders where that product was purchased.

5. **Yearly Growth in Revenue**:
   Calculate the year-over-year revenue growth percentage. Return the year, total revenue for that year, and the percentage change from the previous year (if applicable). Ensure that the first year shows `NULL` for the percentage change.

6. **Average Order Value (AOV) by Country**:
   Write a query to calculate the average order value by country. Include the `country` and the average order value for each country. Order the result by the average order value in descending order.

7. **Top 3 Selling Products by Region**:
   Write a query to find the top 3 selling products in each country. Return the `country`, `product_name`, `category`, and the total quantity sold for each product. For each country, only the top 3 products by quantity should be returned.

---

### Sample Data:

#### `Customers`
| customer_id | customer_name | join_date  | country |
|-------------|---------------|------------|---------|
| 1           | Alice         | 2021-06-01 | USA     |
| 2           | Bob           | 2022-02-15 | UK      |
| 3           | Carol         | 2023-01-10 | USA     |
| 4           | Dave          | 2021-03-22 | Canada  |

#### `Products`
| product_id | product_name   | category   | price |
|------------|----------------|------------|-------|
| 101        | Laptop         | Electronics| 1000  |
| 102        | Smartphone     | Electronics| 500   |
| 103        | TV             | Electronics| 1500  |
| 104        | Headphones     | Accessories| 200   |

#### `Orders`
| order_id | customer_id | order_date | total_amount |
|----------|-------------|------------|--------------|
| 1001     | 1           | 2023-01-01 | 2000         |
| 1002     | 2           | 2023-01-05 | 1500         |
| 1003     | 3           | 2023-02-11 | 500          |
| 1004     | 1           | 2023-03-15 | 1000         |

#### `Order_Items`
| order_item_id | order_id | product_id | quantity | price_at_purchase |
|---------------|----------|------------|----------|-------------------|
| 1             | 1001     | 101        | 1        | 1000              |
| 2             | 1001     | 102        | 1        | 500               |
| 3             | 1002     | 103        | 1        | 1500              |
| 4             | 1003     | 102        | 1        | 500               |
| 5             | 1004     | 101        | 1        | 1000              |

---

### Tips for Solving:
- For **LTV**, you can join the `Orders` and `Order_Items` tables to calculate the total spent by each customer.
- To calculate **monthly revenue**, you might need to extract the month and year from the `order_date` and group by that.
- For **revenue by product**, use `JOIN` between `Order_Items` and `Products` to calculate the total revenue for each product.
- For **year-over-year growth**, use window functions (`LAG`) to get the revenue for the previous year and calculate the growth.
- **Top N products by region** could be solved using `ROW_NUMBER()` and `PARTITION BY` for each country.

### Advanced SQL Techniques to Use:
- **Window Functions**: `ROW_NUMBER()`, `LAG()`, and `RANK()`.
- **Aggregation**: `SUM()`, `AVG()`, `COUNT()`, and grouping by date or other fields.
- **Joins**: INNER JOIN, LEFT JOIN to combine multiple tables.
- **Subqueries**: For filtering or complex calculations.
- **Date Functions**: `YEAR()`, `MONTH()`, `DATE_FORMAT()` for formatting and extracting parts of dates.

Feel free to attempt solving this, and I can help guide you through any parts you're having trouble with!




Here is an advanced SQL interview exercise, along with solutions for each query, covering multiple SQL concepts such as aggregation, window functions, joins, subqueries, and date handling.

### Problem: Sales Analysis and Reporting

**Background:**

We have the following tables:

1. **`Customers`**
   - `customer_id` (INT)
   - `customer_name` (VARCHAR)
   - `join_date` (DATE)
   - `country` (VARCHAR)

2. **`Products`**
   - `product_id` (INT)
   - `product_name` (VARCHAR)
   - `category` (VARCHAR)
   - `price` (DECIMAL)

3. **`Orders`**
   - `order_id` (INT)
   - `customer_id` (INT)
   - `order_date` (DATE)
   - `total_amount` (DECIMAL)

4. **`Order_Items`**
   - `order_item_id` (INT)
   - `order_id` (INT)
   - `product_id` (INT)
   - `quantity` (INT)
   - `price_at_purchase` (DECIMAL)

---

### Exercise Solutions:

#### 1. **Customer's Lifetime Value (LTV)**:
The lifetime value (LTV) is the total amount spent by a customer across all their orders.

**Solution:**
```sql
SELECT
    c.customer_id,
    c.customer_name,
    SUM(oi.quantity * oi.price_at_purchase) AS lifetime_value
FROM
    Customers c
JOIN
    Orders o ON c.customer_id = o.customer_id
JOIN
    Order_Items oi ON o.order_id = oi.order_id
GROUP BY
    c.customer_id, c.customer_name
ORDER BY
    lifetime_value DESC;
```

- **Explanation**: This query joins the `Customers`, `Orders`, and `Order_Items` tables to calculate the total amount spent by each customer. The `SUM()` function is used to aggregate the total spent on all their orders.

---

#### 2. **Top 5 Customers by LTV**:
Find the top 5 customers by lifetime value, including their `customer_name`, `LTV`, and `country`.

**Solution:**
```sql
SELECT
    c.customer_name,
    SUM(oi.quantity * oi.price_at_purchase) AS lifetime_value,
    c.country
FROM
    Customers c
JOIN
    Orders o ON c.customer_id = o.customer_id
JOIN
    Order_Items oi ON o.order_id = oi.order_id
GROUP BY
    c.customer_name, c.country
ORDER BY
    lifetime_value DESC
LIMIT 5;
```

- **Explanation**: This query is similar to the first one but limits the result to the top 5 customers based on their lifetime value. The `LIMIT` clause ensures that only the top 5 customers are returned.

---

#### 3. **Monthly Revenue Trend**:
Calculate the total revenue for each month, ordered by the month and year.

**Solution:**
```sql
SELECT
    DATE_FORMAT(o.order_date, '%Y-%m') AS month_year,
    SUM(oi.quantity * oi.price_at_purchase) AS total_revenue
FROM
    Orders o
JOIN
    Order_Items oi ON o.order_id = oi.order_id
GROUP BY
    month_year
ORDER BY
    month_year;
```

- **Explanation**: The `DATE_FORMAT()` function is used to extract the `YYYY-MM` format from the `order_date` field. Then we group by `month_year` and calculate the total revenue for each month using `SUM()`.

---

#### 4. **Products with the Highest Revenue**:
Identify the top 5 products by revenue, returning their `product_name`, `category`, and total revenue.

**Solution:**
```sql
SELECT
    p.product_name,
    p.category,
    SUM(oi.quantity * oi.price_at_purchase) AS total_revenue
FROM
    Products p
JOIN
    Order_Items oi ON p.product_id = oi.product_id
GROUP BY
    p.product_name, p.category
ORDER BY
    total_revenue DESC
LIMIT 5;
```

- **Explanation**: We join `Products` with `Order_Items` to calculate the total revenue for each product. The `SUM()` function is used to aggregate revenue, and the `LIMIT` clause returns the top 5 products by revenue.

---

#### 5. **Yearly Growth in Revenue**:
Calculate the year-over-year revenue growth percentage.

**Solution:**
```sql
WITH YearlyRevenue AS (
    SELECT
        YEAR(o.order_date) AS year,
        SUM(oi.quantity * oi.price_at_purchase) AS total_revenue
    FROM
        Orders o
    JOIN
        Order_Items oi ON o.order_id = oi.order_id
    GROUP BY
        year
)
SELECT
    year,
    total_revenue,
    LAG(total_revenue) OVER (ORDER BY year) AS previous_year_revenue,
    CASE
        WHEN LAG(total_revenue) OVER (ORDER BY year) IS NULL THEN NULL
        ELSE ((total_revenue - LAG(total_revenue) OVER (ORDER BY year)) / LAG(total_revenue) OVER (ORDER BY year)) * 100
    END AS revenue_growth_percentage
FROM
    YearlyRevenue
ORDER BY
    year;
```

- **Explanation**: This query uses a common table expression (CTE) to first calculate the total revenue for each year. Then, the `LAG()` window function is used to get the revenue of the previous year for each row. The percentage growth is calculated using the formula:  
  \[
  \text{{growth\_percentage}} = \frac{{\text{{current\_revenue}} - \text{{previous\_revenue}}}}{{\text{{previous\_revenue}}}} \times 100
  \]
  If the previous year's revenue is `NULL` (i.e., for the first year), the percentage growth is also `NULL`.

---

#### 6. **Average Order Value (AOV) by Country**:
Calculate the average order value by country.

**Solution:**
```sql
SELECT
    c.country,
    AVG(o.total_amount) AS average_order_value
FROM
    Customers c
JOIN
    Orders o ON c.customer_id = o.customer_id
GROUP BY
    c.country
ORDER BY
    average_order_value DESC;
```

- **Explanation**: We calculate the average order value (`AVG(total_amount)`) for each country by joining the `Customers` and `Orders` tables. The `GROUP BY` clause ensures that the calculation is done per country.

---

#### 7. **Top 3 Selling Products by Region**:
Find the top 3 selling products by country, showing `country`, `product_name`, `category`, and the total quantity sold for each product.

**Solution:**
```sql
WITH ProductSales AS (
    SELECT
        c.country,
        p.product_name,
        p.category,
        SUM(oi.quantity) AS total_quantity_sold
    FROM
        Customers c
    JOIN
        Orders o ON c.customer_id = o.customer_id
    JOIN
        Order_Items oi ON o.order_id = oi.order_id
    JOIN
        Products p ON oi.product_id = p.product_id
    GROUP BY
        c.country, p.product_name, p.category
)
SELECT
    country,
    product_name,
    category,
    total_quantity_sold
FROM (
    SELECT
        country,
        product_name,
        category,
        total_quantity_sold,
        ROW_NUMBER() OVER (PARTITION BY country ORDER BY total_quantity_sold DESC) AS row_num
    FROM
        ProductSales
) AS ranked
WHERE
    row_num <= 3
ORDER BY
    country, total_quantity_sold DESC;
```

- **Explanation**: We use a CTE (`ProductSales`) to calculate the total quantity sold per product in each country. The `ROW_NUMBER()` window function assigns a rank to each product within each country, ordered by the total quantity sold. The outer query filters to return only the top 3 products for each country.

---

### Summary:
These solutions cover a variety of advanced SQL techniques such as:
- **Aggregation** (`SUM()`, `AVG()`)
- **Joins** (`JOIN`, `INNER JOIN`)
- **Window functions** (`ROW_NUMBER()`, `LAG()`)
- **Subqueries and CTEs** for complex aggregations
- **Date functions** for extracting year/month information
- **Ranking** with `ROW_NUMBER()` for top N queries


Sure! Here are a few more advanced SQL query scenarios that cover a range of concepts including recursive queries, performance optimization, advanced joins, CTEs (Common Table Expressions), and handling complex aggregations. These examples can challenge even experienced SQL developers and help prepare for tough interview questions.

### 1. **Recursive Query - Organizational Hierarchy**

You are tasked with querying an organization’s employee hierarchy, where each employee reports to another employee. The table structure is as follows:

#### `Employees`
| employee_id | employee_name | manager_id |
|-------------|---------------|------------|
| 1           | John          | NULL       |
| 2           | Alice         | 1          |
| 3           | Bob           | 1          |
| 4           | Carol         | 2          |
| 5           | Dave          | 2          |
| 6           | Eve           | 3          |

In this case, `manager_id` refers to the `employee_id` of the employee's manager. Write a query to return the entire organizational hierarchy starting from the CEO (top-level manager), showing the employee names and their respective managers.

#### **Solution:**

```sql
WITH RECURSIVE OrgHierarchy AS (
    -- Base case: Select the top-level manager (CEO)
    SELECT employee_id, employee_name, manager_id
    FROM Employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: Select employees and their managers
    SELECT e.employee_id, e.employee_name, e.manager_id
    FROM Employees e
    JOIN OrgHierarchy o ON e.manager_id = o.employee_id
)
SELECT * FROM OrgHierarchy
ORDER BY manager_id, employee_id;
```

- **Explanation**: This query uses a **recursive CTE** to fetch the organizational hierarchy. The base case selects the CEO (the employee without a manager). The recursive part then selects employees who report to the employees already selected in the hierarchy. The recursion continues until all employees are included in the result set.

---

### 2. **Find Duplicates Across Multiple Tables**

Imagine you have multiple tables where you want to identify records that appear in more than one table. Consider two tables:

#### `Products_A`
| product_id | product_name |
|------------|--------------|
| 101        | Laptop       |
| 102        | Smartphone   |
| 103        | Tablet       |

#### `Products_B`
| product_id | product_name |
|------------|--------------|
| 102        | Smartphone   |
| 104        | TV           |
| 105        | Headphones   |

Write a query to find products that appear in **both** `Products_A` and `Products_B`.

#### **Solution:**

```sql
SELECT a.product_id, a.product_name
FROM Products_A a
JOIN Products_B b ON a.product_id = b.product_id
ORDER BY a.product_id;
```

- **Explanation**: A simple **INNER JOIN** finds the products that appear in both `Products_A` and `Products_B`. The result is the list of common products across the two tables.

---

### 3. **Find Nth Highest Salary in a Table**

You are tasked with finding the **Nth highest salary** from an employee table. Here's the `Employees` table:

#### `Employees`
| employee_id | employee_name | salary |
|-------------|---------------|--------|
| 1           | John          | 10000  |
| 2           | Alice         | 12000  |
| 3           | Bob           | 15000  |
| 4           | Carol         | 13000  |
| 5           | Dave          | 8000   |

Write a query to find the **3rd highest salary** from this table.

#### **Solution:**

```sql
SELECT MIN(salary) AS third_highest_salary
FROM (
    SELECT DISTINCT salary
    FROM Employees
    ORDER BY salary DESC
    LIMIT 3
) AS Temp;
```

- **Explanation**: The inner query selects the top 3 distinct salaries ordered by salary in descending order. The outer query then selects the minimum of these salaries, which will be the **3rd highest salary**. This approach handles cases where multiple employees may have the same salary.

---

### 4. **Optimizing Performance with Indexes and Subqueries**

You are asked to find the total amount of sales by each customer. The tables `Orders` and `Order_Items` are quite large, and you are asked to optimize the query. Here’s the schema for the relevant tables:

#### `Orders`
| order_id | customer_id | order_date | total_amount |
|----------|-------------|------------|--------------|
| 1001     | 1           | 2023-01-01 | 2000         |
| 1002     | 2           | 2023-01-02 | 1500         |
| 1003     | 1           | 2023-01-05 | 1000         |

#### `Order_Items`
| order_item_id | order_id | product_id | quantity | price_at_purchase |
|---------------|----------|------------|----------|-------------------|
| 1             | 1001     | 101        | 2        | 1000              |
| 2             | 1002     | 102        | 1        | 500               |
| 3             | 1003     | 103        | 3        | 200               |

To optimize the performance, write the query using a **subquery** and ensure that indexes are created on `Orders.customer_id` and `Order_Items.order_id`.

#### **Solution:**

```sql
SELECT
    o.customer_id,
    SUM(oi.quantity * oi.price_at_purchase) AS total_sales
FROM
    Orders o
JOIN
    Order_Items oi ON o.order_id = oi.order_id
GROUP BY
    o.customer_id;
```

- **Explanation**: The query joins the `Orders` and `Order_Items` tables, calculates the total sales for each customer, and groups the results by `customer_id`. To optimize the performance:
  - Ensure there is an index on `Orders.customer_id` for efficient grouping.
  - Create an index on `Order_Items.order_id` for fast joins.

Indexes will significantly speed up the lookup and join operations on these columns, improving query performance.

---

### 5. **Top N Products Sold in a Month**

Find the top 5 products by quantity sold in a given month, say **January 2023**.

#### **Solution:**

```sql
SELECT 
    p.product_name,
    SUM(oi.quantity) AS total_quantity_sold
FROM 
    Order_Items oi
JOIN 
    Products p ON oi.product_id = p.product_id
JOIN 
    Orders o ON oi.order_id = o.order_id
WHERE 
    o.order_date BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY 
    p.product_name
ORDER BY 
    total_quantity_sold DESC
LIMIT 5;
```

- **Explanation**: This query selects the top 5 products by quantity sold in January 2023. It uses `WHERE` to filter orders by date, `GROUP BY` to aggregate sales per product, and `ORDER BY` to rank the products by quantity sold. The `LIMIT 5` ensures that only the top 5 products are returned.

---

### 6. **Dynamic Pivot Table with Conditional Aggregation**

Given a sales table, create a **dynamic pivot table** that shows the total sales per product category, with columns for each quarter of the year.

#### `Sales`
| sale_id | sale_date | product_id | quantity | total_price |
|---------|-----------|------------|----------|-------------|
| 1       | 2023-01-05| 101        | 2        | 2000        |
| 2       | 2023-04-01| 102        | 1        | 500         |
| 3       | 2023-07-20| 101        | 3        | 3000        |
| 4       | 2023-10-15| 103        | 1        | 1500        |

We want a table that shows the total sales for each product category (from the `Products` table), with columns for **Q1**, **Q2**, **Q3**, and **Q4** based on the sale date.

#### **Solution:**

```sql
SELECT
    p.category,
    SUM(CASE WHEN QUARTER(s.sale_date) = 1 THEN s.total_price ELSE 0 END) AS Q1_sales,
    SUM(CASE WHEN QUARTER(s.sale_date) = 2 THEN s.total_price ELSE 0 END) AS Q2_sales,
    SUM(CASE WHEN QUARTER(s.sale_date) = 3 THEN s.total_price ELSE 0 END) AS Q3_sales,
    SUM(CASE WHEN QUARTER(s.sale_date) = 4 THEN s.total_price ELSE 0 END) AS Q4_sales
FROM
    Sales s
JOIN
    Products p ON s.product_id = p.product_id
GROUP BY
    p.category
ORDER BY
    p.category;
```

- **Explanation**: This query uses conditional aggregation with the `CASE` statement to calculate the sales for each quarter. It groups the results by product category and computes the total sales for each quarter (Q1, Q2, Q3, Q4) using `SUM()` with conditions based on the `QUARTER()` function applied to the `sale_date`.

---

### 7. **Find the Gaps in Sequence**

Suppose you have a table of order IDs (`Orders`) and you need to find the missing order IDs within a given range

.

#### `Orders`
| order_id |
|----------|
| 1        |
| 2        |
| 4        |
| 5        |
| 7        |

Write a query to find the missing `order_id` values in the sequence between 1 and 7.

#### **Solution:**

```sql
WITH RECURSIVE OrderSequence AS (
    SELECT 1 AS order_id
    UNION ALL
    SELECT order_id + 1
    FROM OrderSequence
    WHERE order_id < 7
)
SELECT order_id
FROM OrderSequence
WHERE order_id NOT IN (SELECT order_id FROM Orders)
ORDER BY order_id;
```

- **Explanation**: This query uses a **recursive CTE** to generate a sequence of numbers from 1 to 7. It then filters out the existing `order_id`s from the `Orders` table to find the missing `order_id` values. The result will be the gaps in the sequence.

---

These advanced SQL queries cover complex scenarios that involve recursion, optimization, pivoting, conditional aggregation, and more. Let me know if you would like further details or help with specific queries!

Let me know if you'd like further clarification on any of these queries!
